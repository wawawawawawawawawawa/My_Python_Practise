a = 1
b = a
# 这里首先将1赋值给a,即a指向了1这个对象
# 接着b = a，让变量b也指向 1 这个对象，Python中的对象可以被多个变量引用或指向
# 最后执行 a = a+1 ，在Python的数据类型，整型和字符串等是不可变的，所以a = a+1,并不是让a的值增加1，而是表示重新创建一个新的值为2的对象
# 并让a指向它，但是b仍然指向1
l1 = [1, 2, 3]
l2 = l1
l1.append(4)
print(l1)
print(l2)
# 由于列表是可变的，所以l1.append(4)不会创建新的列表,只是在原列表插入元素4，所以l1，l2都会改变
del l1
print(l2)
# Python里的变量可以被删除，但是对象无法被删除，del删除了这个变量，但是对象依然存在，如果对象的引用全部被删除时，就会被自带的垃圾回收回收
# 由此可见在Python中：
# 1.变量的赋值，只是让变量指向了某个对象，并不表示拷贝对象给变量，一个对象可以被多个变量指向
# 2.可变对象的改变，会影响所有指向该对象的变量
# 3.对于不可变对象(字符串，整型，元组等),所有指向该对象的变量的值总是一样的，也不会改变，但是通过 += 等操作更新不可变对象的值时，会返回一个新的对象
# 4.变量可以被删除，对象不行


# Python 的参数传递是赋值传递 （pass by assignment），或者叫作对象的引用传递（pass by object reference）。Python 里所有的数据类型都是对象，所以参数传递时，
# 只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说
def my_func1(b):
    b = 2
a = 1
my_func1(a)
print(a)  # 这里只是修改了b的指向，不会改变a 的值


def my_func2(b):
    b = 2
    return b
a = 1
a = my_func2(a)
print(a)   # 赋予了a新值  所以a改变了


def my_func(l2):
    l2 = l2 + [4]
l1 = [1, 2, 3]
my_func(l1)
print(l1)  # 这里l1不会改变，因为是创建了一个新列表赋值给了lx，与l1无关


